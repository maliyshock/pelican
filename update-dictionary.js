import fs from "fs";
import path from "path";

// this piece of shit has been generated by chat-gpt, while it does its job i do not care

// пройтись по всем файлам и папкам в nodes
// для каждой ноды:
// - посмотреть на ее тип, сходить в dictionary и проверить что там он есть, если нет то добавить
// - проверить есть ли импорт в ноде если нет то добавить
// - посмотреть на ее роль
// зайти в src/types/index.ts
// если такой тип уже есть - расширить, если нет то создать и добавить в entities

const __dirname = path.dirname(new URL(import.meta.url).pathname);
const nodesFolder = path.join(__dirname, "src/constants/nodes");
const dictionaryFile = path.join(__dirname, "src/constants/dictionary.ts");
const typesFile = path.join(__dirname, "src/types/index.ts");
//
// function findFiles(dir, fileList = []) {
//   const files = fs.readdirSync(dir);
//
//   files.forEach(file => {
//     const filePath = path.join(dir, file);
//
//     if (fs.statSync(filePath).isDirectory()) {
//       findFiles(filePath, fileList);
//     } else {
//       fileList.push(filePath);
//     }
//   });
//
//   return fileList;
// }
//
// function getFileContent(filePath) {
//   if (fs.existsSync(filePath)) {
//     return fs.readFileSync(filePath, "utf8");
//   }
//
//   return "";
// }
//
// function updateDictionary(dictionaryContent, newConstants) {
//   newConstants.forEach(constant => {
//     if (!dictionaryContent.includes(`export const ${constant}`)) {
//       const formattedConstant = constant.toLowerCase().replace(/_/g, "-");
//
//       dictionaryContent += `export const ${constant} = "${formattedConstant}";\n`;
//     }
//   });
//   fs.writeFileSync(dictionaryFile, dictionaryContent, "utf8");
// }
//
// function parseNodeFile(fileContent) {
//   const rootRegex = /root:\s*(\w+)/;
//   const typeRegex = /type:\s*(\w+)/;
//   const rolesRegex = /roles:\s*\[(\w+)\]/;
//
//   const rootMatch = fileContent.match(rootRegex);
//   const typeMatch = fileContent.match(typeRegex);
//   const rolesMatch = fileContent.match(rolesRegex);
//
//   const newConstants = [];
//   let role = null;
//
//   if (rootMatch) newConstants.push(rootMatch[1]);
//   if (typeMatch) newConstants.push(typeMatch[1]);
//   if (rolesMatch) role = rolesMatch[1];
//
//   return { newConstants, role };
// }
//
// function toCamelCase(string) {
//   return string
//     .toLowerCase()
//     .replace(/_([a-z])/g, g => g[1].toUpperCase())
//     .replace(/^[a-z]/, g => g.toUpperCase());
// }
//
// function updateTypesFile(typesContent, role, constant) {
//   const typeName = toCamelCase(role);
//   const typeRegex = new RegExp(`export type ${typeName} = ([^;]+);`);
//   const match = typesContent.match(typeRegex);
//
//   if (match) {
//     if (!match[1].includes(`typeof ${constant}`)) {
//       const updatedType = `${match[1]} | typeof ${constant}`;
//
//       typesContent = typesContent.replace(typeRegex, `export type ${typeName} = ${updatedType};`);
//     }
//   } else {
//     const newType = `export type ${typeName} = typeof ${constant};\n`;
//
//     typesContent += newType;
//   }
//
//   const importRegex = /import\s*{\s*([^}]+)\s*}\s*from\s*["']~\/constants\/dictionary\.ts["'];?/;
//   const importMatch = typesContent.match(importRegex);
//
//   if (importMatch) {
//     const existingConstants = importMatch[1].split(",").map(item => item.trim());
//
//     if (!existingConstants.includes(constant)) {
//       const updatedConstants = [...existingConstants, constant].join(", ");
//
//       typesContent = typesContent.replace(importRegex, `import { ${updatedConstants} } from "~/constants/dictionary.ts";`);
//     }
//   } else {
//     const importStatement = `import { ${constant} } from "~/constants/dictionary.ts";\n`;
//
//     typesContent = importStatement + typesContent;
//   }
//
//   return typesContent;
// }
//
// function updateNodeFile(filePath, newConstants) {
//   let fileContent = fs.readFileSync(filePath, "utf8");
//   const importRegex = /import\s*{\s*([^}]+)\s*}\s*from\s*["']~\/constants\/dictionary\.ts["'];?/;
//   const importMatch = fileContent.match(importRegex);
//
//   if (importMatch) {
//     const existingConstants = importMatch[1].split(",").map(item => item.trim());
//     const uniqueConstants = new Set([...existingConstants, ...newConstants]);
//     const updatedConstants = Array.from(uniqueConstants).join(", ");
//
//     fileContent = fileContent.replace(importRegex, `import { ${updatedConstants} } from "~/constants/dictionary.ts";`);
//   } else {
//     const importStatement = `import { ${newConstants.join(", ")} } from "~/constants/dictionary.ts";\n`;
//     const exportRegex = /^(export\sconst\s)/m;
//     const match = fileContent.match(exportRegex);
//
//     if (match) {
//       const position = match.index;
//
//       fileContent = fileContent.slice(0, position) + importStatement + fileContent.slice(position);
//     }
//   }
//
//   fs.writeFileSync(filePath, fileContent, "utf8");
// }
//
// const allFiles = findFiles(nodesFolder);
// let dictionaryContent = getFileContent(dictionaryFile);
// let typesContent = getFileContent(typesFile);
// const newConstants = [];
// const roles = [];
//
// allFiles.forEach(file => {
//   if (file.endsWith(".ts")) {
//     const fileContent = fs.readFileSync(file, "utf8");
//     const { newConstants: constants, role } = parseNodeFile(fileContent);
//
//     if (constants.length > 0) {
//       updateNodeFile(file, constants);
//     }
//
//     newConstants.push(...constants);
//     if (role) roles.push({ role, constant: constants[0] });
//   }
// });
//
// updateDictionary(dictionaryContent, newConstants);
//
// roles.forEach(({ role, constant }) => {
//   typesContent = updateTypesFile(typesContent, role, constant);
// });

fs.writeFileSync(typesFile, typesContent, "utf8");
